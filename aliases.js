var ALIASES = {};
ALIASES["async_trait"] = {};
ALIASES["downcast_rs"] = {};
ALIASES["icu"] = {};
ALIASES["icu4x"] = {};
ALIASES["icu_data_provider"] = {};
ALIASES["icu_data_provider_json"] = {};
ALIASES["icu_locale"] = {};
ALIASES["itoa"] = {};
ALIASES["no_std_compat"] = {"<<=":[{'crate':'no_std_compat','ty':8,'name':'ShlAssign','desc':'The left shift assignment operator `<<=`.','p':'no_std_compat::ops'}],"]":[{'crate':'no_std_compat','ty':8,'name':'Index','desc':'Used for indexing operations (`container[index]`) in…','p':'no_std_compat::ops'},{'crate':'no_std_compat','ty':8,'name':'IndexMut','desc':'Used for indexing operations (`container[index]`) in…','p':'no_std_compat::ops'}],"?":[{'crate':'no_std_compat','ty':8,'name':'Try','desc':'A trait for customizing the behavior of the `?` operator.','p':'no_std_compat::ops'},{'crate':'no_std_compat','ty':14,'name':'try','desc':'Unwraps a result or propagates its error.','p':'no_std_compat'}],"*":[{'crate':'no_std_compat','ty':8,'name':'Mul','desc':'The multiplication operator `*`.','p':'no_std_compat::ops'},{'crate':'no_std_compat','ty':8,'name':'MulAssign','desc':'The multiplication assignment operator `*=`.','p':'no_std_compat::ops'},{'crate':'no_std_compat','ty':8,'name':'Deref','desc':'Used for immutable dereferencing operations, like `*v`.','p':'no_std_compat::ops'},{'crate':'no_std_compat','ty':8,'name':'DerefMut','desc':'Used for mutable dereferencing operations, like in `*v =…','p':'no_std_compat::ops'}],">=":[{'crate':'no_std_compat','ty':8,'name':'Ord','desc':'Trait for types that form a total order.','p':'no_std_compat::prelude::v1'},{'crate':'no_std_compat','ty':8,'name':'PartialOrd','desc':'Trait for values that can be compared for a sort-order.','p':'no_std_compat::prelude::v1'},{'crate':'no_std_compat','ty':8,'name':'Ord','desc':'Trait for types that form a total order.','p':'no_std_compat::cmp'},{'crate':'no_std_compat','ty':8,'name':'PartialOrd','desc':'Trait for values that can be compared for a sort-order.','p':'no_std_compat::cmp'},{'crate':'no_std_compat','ty':8,'name':'Ord','desc':'Trait for types that form a total order.','p':'no_std_compat::prelude::v1'},{'crate':'no_std_compat','ty':8,'name':'PartialOrd','desc':'Trait for values that can be compared for a sort-order.','p':'no_std_compat::prelude::v1'}],"..=":[{'crate':'no_std_compat','ty':3,'name':'RangeInclusive','desc':'A range bounded inclusively below and above (`start..=end`).','p':'no_std_compat::ops'},{'crate':'no_std_compat','ty':3,'name':'RangeToInclusive','desc':'A range only bounded inclusively above (`..=end`).','p':'no_std_compat::ops'}],"^=":[{'crate':'no_std_compat','ty':8,'name':'BitXorAssign','desc':'The bitwise XOR assignment operator `^=`.','p':'no_std_compat::ops'}],">":[{'crate':'no_std_compat','ty':8,'name':'Ord','desc':'Trait for types that form a total order.','p':'no_std_compat::prelude::v1'},{'crate':'no_std_compat','ty':8,'name':'PartialOrd','desc':'Trait for values that can be compared for a sort-order.','p':'no_std_compat::prelude::v1'},{'crate':'no_std_compat','ty':8,'name':'Ord','desc':'Trait for types that form a total order.','p':'no_std_compat::cmp'},{'crate':'no_std_compat','ty':8,'name':'PartialOrd','desc':'Trait for values that can be compared for a sort-order.','p':'no_std_compat::cmp'},{'crate':'no_std_compat','ty':8,'name':'Ord','desc':'Trait for types that form a total order.','p':'no_std_compat::prelude::v1'},{'crate':'no_std_compat','ty':8,'name':'PartialOrd','desc':'Trait for values that can be compared for a sort-order.','p':'no_std_compat::prelude::v1'}],"<=":[{'crate':'no_std_compat','ty':8,'name':'Ord','desc':'Trait for types that form a total order.','p':'no_std_compat::prelude::v1'},{'crate':'no_std_compat','ty':8,'name':'PartialOrd','desc':'Trait for values that can be compared for a sort-order.','p':'no_std_compat::prelude::v1'},{'crate':'no_std_compat','ty':8,'name':'Ord','desc':'Trait for types that form a total order.','p':'no_std_compat::cmp'},{'crate':'no_std_compat','ty':8,'name':'PartialOrd','desc':'Trait for values that can be compared for a sort-order.','p':'no_std_compat::cmp'},{'crate':'no_std_compat','ty':8,'name':'Ord','desc':'Trait for types that form a total order.','p':'no_std_compat::prelude::v1'},{'crate':'no_std_compat','ty':8,'name':'PartialOrd','desc':'Trait for values that can be compared for a sort-order.','p':'no_std_compat::prelude::v1'}],"^":[{'crate':'no_std_compat','ty':8,'name':'BitXor','desc':'The bitwise XOR operator `^`.','p':'no_std_compat::ops'}],"&=":[{'crate':'no_std_compat','ty':8,'name':'BitAndAssign','desc':'The bitwise AND assignment operator `&=`.','p':'no_std_compat::ops'}],"[]":[{'crate':'no_std_compat','ty':8,'name':'Index','desc':'Used for indexing operations (`container[index]`) in…','p':'no_std_compat::ops'},{'crate':'no_std_compat','ty':8,'name':'IndexMut','desc':'Used for indexing operations (`container[index]`) in…','p':'no_std_compat::ops'}],"+":[{'crate':'no_std_compat','ty':8,'name':'Add','desc':'The addition operator `+`.','p':'no_std_compat::ops'},{'crate':'no_std_compat','ty':8,'name':'AddAssign','desc':'The addition assignment operator `+=`.','p':'no_std_compat::ops'}],"%":[{'crate':'no_std_compat','ty':8,'name':'Rem','desc':'The remainder operator `%`.','p':'no_std_compat::ops'},{'crate':'no_std_compat','ty':8,'name':'RemAssign','desc':'The remainder assignment operator `%=`.','p':'no_std_compat::ops'}],">>=":[{'crate':'no_std_compat','ty':8,'name':'ShrAssign','desc':'The right shift assignment operator `>>=`.','p':'no_std_compat::ops'}],"/":[{'crate':'no_std_compat','ty':8,'name':'Div','desc':'The division operator `/`.','p':'no_std_compat::ops'},{'crate':'no_std_compat','ty':8,'name':'DivAssign','desc':'The division assignment operator `/=`.','p':'no_std_compat::ops'}],"[":[{'crate':'no_std_compat','ty':8,'name':'Index','desc':'Used for indexing operations (`container[index]`) in…','p':'no_std_compat::ops'},{'crate':'no_std_compat','ty':8,'name':'IndexMut','desc':'Used for indexing operations (`container[index]`) in…','p':'no_std_compat::ops'}],"..":[{'crate':'no_std_compat','ty':3,'name':'Range','desc':'A (half-open) range bounded inclusively below and…','p':'no_std_compat::ops'},{'crate':'no_std_compat','ty':3,'name':'RangeFrom','desc':'A range only bounded inclusively below (`start..`).','p':'no_std_compat::ops'},{'crate':'no_std_compat','ty':3,'name':'RangeFull','desc':'An unbounded range (`..`).','p':'no_std_compat::ops'},{'crate':'no_std_compat','ty':3,'name':'RangeTo','desc':'A range only bounded exclusively above (`..end`).','p':'no_std_compat::ops'}],"<<":[{'crate':'no_std_compat','ty':8,'name':'Shl','desc':'The left shift operator `<<`. Note that because this trait…','p':'no_std_compat::ops'}],"{}":[{'crate':'no_std_compat','ty':8,'name':'Display','desc':'Format trait for an empty format, `{}`.','p':'no_std_compat::fmt'}],"<":[{'crate':'no_std_compat','ty':8,'name':'Ord','desc':'Trait for types that form a total order.','p':'no_std_compat::prelude::v1'},{'crate':'no_std_compat','ty':8,'name':'PartialOrd','desc':'Trait for values that can be compared for a sort-order.','p':'no_std_compat::prelude::v1'},{'crate':'no_std_compat','ty':8,'name':'Ord','desc':'Trait for types that form a total order.','p':'no_std_compat::cmp'},{'crate':'no_std_compat','ty':8,'name':'PartialOrd','desc':'Trait for values that can be compared for a sort-order.','p':'no_std_compat::cmp'},{'crate':'no_std_compat','ty':8,'name':'Ord','desc':'Trait for types that form a total order.','p':'no_std_compat::prelude::v1'},{'crate':'no_std_compat','ty':8,'name':'PartialOrd','desc':'Trait for values that can be compared for a sort-order.','p':'no_std_compat::prelude::v1'}],"*=":[{'crate':'no_std_compat','ty':8,'name':'MulAssign','desc':'The multiplication assignment operator `*=`.','p':'no_std_compat::ops'}],"&":[{'crate':'no_std_compat','ty':8,'name':'BitAnd','desc':'The bitwise AND operator `&`.','p':'no_std_compat::ops'}],"|=":[{'crate':'no_std_compat','ty':8,'name':'BitOrAssign','desc':'The bitwise OR assignment operator `|=`.','p':'no_std_compat::ops'}],"|":[{'crate':'no_std_compat','ty':8,'name':'BitOr','desc':'The bitwise OR operator `|`.','p':'no_std_compat::ops'}],"&*":[{'crate':'no_std_compat','ty':8,'name':'Deref','desc':'Used for immutable dereferencing operations, like `*v`.','p':'no_std_compat::ops'}],">>":[{'crate':'no_std_compat','ty':8,'name':'Shr','desc':'The right shift operator `>>`. Note that because this…','p':'no_std_compat::ops'}],"-=":[{'crate':'no_std_compat','ty':8,'name':'SubAssign','desc':'The subtraction assignment operator `-=`.','p':'no_std_compat::ops'}],"==":[{'crate':'no_std_compat','ty':8,'name':'Eq','desc':'Trait for equality comparisons which are equivalence…','p':'no_std_compat::prelude::v1'},{'crate':'no_std_compat','ty':8,'name':'PartialEq','desc':'Trait for equality comparisons which are partial…','p':'no_std_compat::prelude::v1'},{'crate':'no_std_compat','ty':8,'name':'PartialEq','desc':'Trait for equality comparisons which are partial…','p':'no_std_compat::cmp'},{'crate':'no_std_compat','ty':8,'name':'Eq','desc':'Trait for equality comparisons which are equivalence…','p':'no_std_compat::cmp'},{'crate':'no_std_compat','ty':8,'name':'Eq','desc':'Trait for equality comparisons which are equivalence…','p':'no_std_compat::prelude::v1'},{'crate':'no_std_compat','ty':8,'name':'PartialEq','desc':'Trait for equality comparisons which are partial…','p':'no_std_compat::prelude::v1'}],"!=":[{'crate':'no_std_compat','ty':8,'name':'Eq','desc':'Trait for equality comparisons which are equivalence…','p':'no_std_compat::prelude::v1'},{'crate':'no_std_compat','ty':8,'name':'PartialEq','desc':'Trait for equality comparisons which are partial…','p':'no_std_compat::prelude::v1'},{'crate':'no_std_compat','ty':8,'name':'PartialEq','desc':'Trait for equality comparisons which are partial…','p':'no_std_compat::cmp'},{'crate':'no_std_compat','ty':8,'name':'Eq','desc':'Trait for equality comparisons which are equivalence…','p':'no_std_compat::cmp'},{'crate':'no_std_compat','ty':8,'name':'Eq','desc':'Trait for equality comparisons which are equivalence…','p':'no_std_compat::prelude::v1'},{'crate':'no_std_compat','ty':8,'name':'PartialEq','desc':'Trait for equality comparisons which are partial…','p':'no_std_compat::prelude::v1'}],"memcpy":[{'crate':'no_std_compat','ty':5,'name':'copy_nonoverlapping','desc':'Copies `count * size_of::<T>()` bytes from `src` to `dst`.…','p':'no_std_compat::intrinsics'},{'crate':'no_std_compat','ty':5,'name':'copy_nonoverlapping','desc':'Copies `count * size_of::<T>()` bytes from `src` to `dst`.…','p':'no_std_compat::ptr'}],"memmove":[{'crate':'no_std_compat','ty':5,'name':'copy','desc':'Copies `count * size_of::<T>()` bytes from `src` to `dst`.…','p':'no_std_compat::intrinsics'},{'crate':'no_std_compat','ty':5,'name':'copy','desc':'Copies `count * size_of::<T>()` bytes from `src` to `dst`.…','p':'no_std_compat::ptr'}],"{:?}":[{'crate':'no_std_compat','ty':8,'name':'Debug','desc':'`?` formatting.','p':'no_std_compat::fmt'}],"-":[{'crate':'no_std_compat','ty':8,'name':'Neg','desc':'The unary negation operator `-`.','p':'no_std_compat::ops'},{'crate':'no_std_compat','ty':8,'name':'Sub','desc':'The subtraction operator `-`.','p':'no_std_compat::ops'},{'crate':'no_std_compat','ty':8,'name':'SubAssign','desc':'The subtraction assignment operator `-=`.','p':'no_std_compat::ops'}],"+=":[{'crate':'no_std_compat','ty':8,'name':'AddAssign','desc':'The addition assignment operator `+=`.','p':'no_std_compat::ops'}],"/=":[{'crate':'no_std_compat','ty':8,'name':'DivAssign','desc':'The division assignment operator `/=`.','p':'no_std_compat::ops'}],"%=":[{'crate':'no_std_compat','ty':8,'name':'RemAssign','desc':'The remainder assignment operator `%=`.','p':'no_std_compat::ops'}],};
ALIASES["proc_macro2"] = {};
ALIASES["quote"] = {};
ALIASES["ryu"] = {};
ALIASES["serde"] = {};
ALIASES["serde_derive"] = {};
ALIASES["serde_json"] = {};
ALIASES["syn"] = {};
ALIASES["tinystr"] = {};
ALIASES["unicode_xid"] = {};
